use futures::prelude::*;
use multiaddr::Multiaddr;
use multiaddr::PeerId;
use std::{
	error::Error,
	fmt,
	pin::Pin,
	task::{Context, Poll},
};

pub mod map;
pub mod map_err;

mod boxed;

pub use boxed::*;

use crate::Protocol;

#[derive(Debug, Clone)]
pub enum TransportError<TErr> {
	/// The [`Multiaddr`] passed as parameter is not supported.
	///
	/// Contains back the same address.
	MultiaddrNotSupported(Multiaddr),

	/// Any other error that a [`Transport`] may produce.
	Other(TErr),
}

impl<TErr> TransportError<TErr> {
	/// Applies a function to the error in [`TransportError::Other`].
	pub fn map<TNewErr>(self, map: impl FnOnce(TErr) -> TNewErr) -> TransportError<TNewErr> {
		match self {
			TransportError::MultiaddrNotSupported(addr) => TransportError::MultiaddrNotSupported(addr),
			TransportError::Other(err) => TransportError::Other(map(err)),
		}
	}
}

impl<TErr> fmt::Display for TransportError<TErr>
where
	TErr: fmt::Display,
{
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		match self {
			TransportError::MultiaddrNotSupported(addr) => {
				write!(f, "Multiaddr is not supported: {addr}")
			}
			TransportError::Other(_) => Ok(()),
		}
	}
}

impl<TErr> Error for TransportError<TErr>
where
	TErr: Error + 'static,
{
	fn source(&self) -> Option<&(dyn Error + 'static)> {
		match self {
			TransportError::MultiaddrNotSupported(_) => None,
			TransportError::Other(err) => Some(err),
		}
	}
}

#[derive(Debug)]
pub enum TransportEvent<TUpgrade, TError> {
	Incoming {
		remote_addr: Multiaddr,
		local_addr: Multiaddr,
		upgrade: TUpgrade,
	},

	ListenAddress {
		address: Multiaddr,
	},

	AddressExpired {
		address: Multiaddr,
	},

	ListenerError {
		error: TError,
	},

	ListenerClosed {
		reason: Result<(), TError>,
	},
}

pub trait Transport {
	type Output;
	type Error: Error;
	type Dial: Future<Output = Result<Self::Output, Self::Error>>;
	type ListenerUpgrade: Future<Output = Result<Self::Output, Self::Error>>;

	fn supported_protocols_for_dialing(&self) -> Protocol;
	fn dial(&mut self, address: Multiaddr) -> Result<Self::Dial, TransportError<Self::Error>>;
	fn listen_on(&mut self, address: Multiaddr) -> Result<(), TransportError<Self::Error>>;

	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<TransportEvent<Self::ListenerUpgrade, Self::Error>>;

	/// Boxes the transport, including custom transport errors.
	fn boxed(self) -> boxed::Boxed<Self::Output>
	where
		Self: Sized + Send + Unpin + 'static,
		Self::Dial: Send + 'static,
		Self::ListenerUpgrade: Send + 'static,
		Self::Error: Send + Sync,
	{
		boxed::boxed(self)
	}

	/// Applies a function on the connections created by the transport.
	fn map<F, O>(self, f: F) -> map::Map<Self, F>
	where
		Self: Sized,
		F: FnOnce(Self::Output) -> O,
	{
		map::Map::new(self, f)
	}

	/// Applies a function on the errors generated by the futures of the transport.
	fn map_err<F, E>(self, f: F) -> map_err::MapErr<Self, F>
	where
		Self: Sized,
		F: FnOnce(Self::Error) -> E,
	{
		map_err::MapErr::new(self, f)
	}
}

impl<TUpgr, TErr> TransportEvent<TUpgr, TErr> {
	/// In case this [`TransportEvent`] is an upgrade, apply the given function
	/// to the upgrade and produce another transport event based the function's result.
	pub fn map_upgrade<U>(self, map: impl FnOnce(TUpgr) -> U) -> TransportEvent<U, TErr> {
		match self {
			TransportEvent::Incoming {
				upgrade,
				local_addr,
				remote_addr,
			} => TransportEvent::Incoming {
				upgrade: map(upgrade),
				local_addr,
				remote_addr,
			},
			TransportEvent::ListenAddress { address } => TransportEvent::ListenAddress { address },
			TransportEvent::AddressExpired { address } => TransportEvent::AddressExpired { address },
			TransportEvent::ListenerError { error } => TransportEvent::ListenerError { error },
			TransportEvent::ListenerClosed { reason } => TransportEvent::ListenerClosed { reason },
		}
	}

	/// In case this [`TransportEvent`] is an [`ListenerError`](TransportEvent::ListenerError),
	/// or [`ListenerClosed`](TransportEvent::ListenerClosed) apply the given function to the
	/// error and produce another transport event based on the function's result.
	pub fn map_err<E>(self, map_err: impl FnOnce(TErr) -> E) -> TransportEvent<TUpgr, E> {
		match self {
			TransportEvent::Incoming {
				upgrade,
				local_addr,
				remote_addr,
			} => TransportEvent::Incoming {
				upgrade,
				local_addr,
				remote_addr,
			},
			TransportEvent::ListenAddress { address } => TransportEvent::ListenAddress { address },
			TransportEvent::AddressExpired { address } => TransportEvent::AddressExpired { address },
			TransportEvent::ListenerError { error } => TransportEvent::ListenerError { error: map_err(error) },
			TransportEvent::ListenerClosed { reason } => TransportEvent::ListenerClosed {
				reason: reason.map_err(map_err),
			},
		}
	}
}
